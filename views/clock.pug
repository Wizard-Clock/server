extends layout

block content
    div(class="row justify-content-center")
        div(class="d-flex justify-content-center align-items-center" id="clockDiv")
            canvas(id="wizardingClockFace" class="img-fluid" width="871" height="846")

    script.
        const canvas = document.getElementById('wizardingClockFace');
        const ctx = canvas.getContext('2d');
        let clockPositions = JSON.parse('!{JSON.stringify(clockPositions)}');
        let usersClockPosition = JSON.parse('!{JSON.stringify(usersClockPosition)}');
        const currentState = [];

        // Add image to Canvas
        const img = new Image();
        img.crossOrigin = 'anonymous';
        img.src = '/public/images/wizarding-clock-face.jpg';
        img.alt = "Wizarding Clock Face";
        img.onload = function () {
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            ctx.translate(canvas.width/2, canvas.height/2);
            drawNumbers(ctx, (canvas.height)/2, clockPositions);
            drawTime(ctx, (canvas.height)/2, clockPositions, usersClockPosition);
        };

        // Much help from https://github.com/malcolmrigg/wizard-clock-card/tree/master
        async function drawNumbers(ctx, radius, positions) {
            let selectedFont = 'Xanh Mono';
            ctx.textBaseline = "middle";
            ctx.textAlign = "center";
            ctx.fillStyle = 'black';

            // Have to compensate for the clock not being a true circle
            const startingAdjustArray = [0.81, 0.82, 0.76, 0.76, 0.74, 0.74, 0.73, 0.73, 0.75, 0.73, 0.71, 0.71, .79];
            const ovalCompensateArray = [0, 5, 10, 10, 7, 3, 0, 3, 7, 6, 4, -2, -3];


            for (let num = 0; num < positions.length; num++) {
                // Unfun Required Math
                const positionTranslateArray = [-99, -75, -68, -72, -83,  -98,  -110, -122, -132, -140, -146, -148];
                const positionRotateArray =    [-55, -30,  -5,  20,  35,    40,   38,   38,   38,   28,   17,   10];
                const fontScaleArray =         [0.9, 0.8, 0.7, 0.6, 0.6,  0.55, 0.55,  0.5,  0.5, 0.45,  0.4, 0.35];
                const charWidthArray =              [3.8,   4, 3.9, 3.5,   2.8,  2.5,  2.5,  2.5,  2.8,  2.8,  2.8];

                ctx.resetTransform();
                ctx.translate(canvas.width/2, canvas.height/2);
                let ang = (2 * Math.PI / positions.length) * (num + startingAdjustArray[num]);
                ctx.rotate(ang);

                // Now draw, rotate, reset, and repeat
                let text = positions[num].name.toUpperCase();
                for (let j = 0; j < text.length; j++) {
                    ctx.font = "bold " + radius*0.15*fontScaleArray[j] + "px " + selectedFont;

                    ctx.translate(0, (0 - (radius + ovalCompensateArray[num] + positionTranslateArray[j])));
                    ctx.rotate(positionRotateArray[j] * Math.PI /180);

                    ctx.fillText(text[j], 0, 0);

                    ctx.rotate(-positionRotateArray[j] * Math.PI /180);
                    ctx.translate(0, -(0 - (radius + ovalCompensateArray[num] + positionTranslateArray[j])));

                    ctx.rotate((charWidthArray[j]) * Math.PI /180);
                }

            }
        }

        async function drawTime(ctx, radius, locations, wizardClockPositions){
            ctx.resetTransform();
            ctx.translate(canvas.width / 2, canvas.height / 2);
            const targetState = [];
            for (let num = 0; num < wizardClockPositions.length; num++) {
                const wizardClockPosition = wizardClockPositions[num];
                const wizardOffset = ((num - ((wizardClockPositions.length - 1) / 2)) / wizardClockPositions.length * 0.6);
                let location = wizardOffset;
                for (let loc of locations) {
                    if (loc.name === wizardClockPosition.position.name) {
                        location = wizardOffset + loc.face_position;
                    }
                }
                location = (2 * Math.PI / locations.length) * (location+ .2);

                // set targetstate
                targetState.push({
                    pos: location,
                    length: radius * 0.7,
                    width: radius * 0.05,
                    wizard: wizardClockPositions[num].name,
                });
            }

            // update currentstate from targetstate
            if (!currentState) {
                currentState.length = 0;
            }
            for (let num = 0; num < wizardClockPositions.length; num++) {
                if (currentState[num]) {
                    currentState[num].pos = currentState[num].pos + ((targetState[num].pos - currentState[num].pos) / 60);
                } else {
                    currentState.push({
                        pos: targetState[num].pos,
                        length: targetState[num].length,
                        width: targetState[num].width,
                        wizard: targetState[num].wizard
                    });
                }
            }
            // draw currentState
            for (let num = 0; num < wizardClockPositions.length; num++) {
                this.drawHand(ctx, currentState[num].pos, currentState[num].length, currentState[num].width, currentState[num].wizard);
            }
        }

        function drawHand(ctx, pos, length, width, wizard) {
            let fontScale = 0.3;
            let selectedFont = 'Aboreto';
            const scissorObj = new Image();
            scissorObj.src = '/public/images/half-scissor-outline.png';
            scissorObj.alt = "Clock Hand";
            scissorObj.id = wizard + "-clock-hand";
            scissorObj.onload = function () {
                ctx.rotate(pos);
                ctx.drawImage(scissorObj, -20, -300, 75, 450);

                ctx.font = "bolder " + width * 3 * fontScale + "px " + selectedFont;
                ctx.fillStyle = "white";
                ctx.translate(0, -length / 2);
                ctx.rotate(Math.PI / 2)
                if (pos < Math.PI && pos >= 0) {
                    ctx.rotate(Math.PI);
                }
                ctx.fillText(wizard.toUpperCase(), 0, 0);
                if (pos < Math.PI && pos >= 0) {
                    ctx.rotate(-Math.PI);
                }
                ctx.rotate(-Math.PI / 2);
                ctx.translate(0, length / 2);

                ctx.rotate(-pos);
            };
        }



