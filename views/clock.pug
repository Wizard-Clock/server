extends layout

block content
    div(class="row justify-content-center")
        div(class="d-flex justify-content-center align-items-center" id="clockDiv")
            canvas(id="wizardingClockFace" class="img-fluid" width="871" height="846")
        div(class="d-flex justify-content-center align-items-center mt-3")
            a(role="button" class="btn btn-outline-secondary" href="/clock/standalone" target="_blank") Open Fullscreen Clock&nbsp;
                i(class="bi bi-clock")
        div(class="col-auto w-75")
            div()
                h1(class="py-2 my-4 border-bottom") Clock Face Management
                table(class="table table-striped table-hover")
                    thead()
                        tr()
                            th(scope="col") Position Number
                            th(scope="col") Name
                            th(scope="col") Assigned Locations
                            th(scope="col") Edit
                    tbody()
                        each position in clockPositions
                            tr()
                                th(scope="row")= position.face_position
                                td()= position.name
                                if position.face_position === 13
                                    td()= "Roaming values not assigned to any location."
                                else
                                    td()= "TBD"
                                td()
                                    button(type="button" class="btn btn-light" data-bs-toggle="modal" data-bs-target="#editClockPositionModal" data-bs-position= position)
                                        i(class="bi bi-pencil-square")

    div(class="modal fade" id="editClockPositionModal" data-bs-backdrop="static" data-bs-keyboard="false" tabindex="-1" aria-labelledby="editClockPositionModalLabel" aria-hidden="true")
        div(class="modal-dialog modal-dialog-centered")
            div(class="modal-content")
                div(class="modal-header")
                    h1(class="modal-title fs-5" id="editClockPositionModalLabel") Edit Clock Position
                    button(type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close")
                div(class="modal-body")
                    form(class="row g-3" id="editClockPositionForm")
                        div(class="col-md-4")
                            section()
                                label(for="clockPositionNumberInput" class="form-label") Position Number
                                input(type="text" class="form-control pos-num" name="face_position" id="clockPositionNumberInput" required disabled)
                        div(class="col-md-8")
                                label(for="clockPositionNameInput" class="form-label") Name&nbsp;
                                i(class="bi bi-question-circle-fill" data-bs-toggle="tooltip" data-bs-title="Must be 12 characters or less. Name is in all Uppercase.")
                                input(type="text" style="text-transform: uppercase;" class="form-control pos-name" name="name" id="clockPositionNameInput" maxlength=12 required)
                        div(class="col-12")
                            button(type="submit" class="btn btn-primary") Save Changes
                div(class="modal-footer")
                    button(type="button" class="btn btn-secondary" data-bs-dismiss="modal") Cancel
    script.
        document.querySelectorAll('[data-bs-toggle="tooltip"]').forEach(tooltip => {
            new bootstrap.Tooltip(tooltip);
        })

        const { cubicBezier } = Motion;
        const canvas = document.getElementById('wizardingClockFace');
        const ctx = canvas.getContext('2d');
        let clockPositions = JSON.parse('!{JSON.stringify(clockPositions)}');
        let wizardWithPositionArray = JSON.parse('!{JSON.stringify(usersClockPosition)}');
        const currentWizardState = [];
        const targetWizardState = [];
        let firstUpdate = true;

        const clockFace = new Image();
        clockFace.crossOrigin = 'anonymous';
        clockFace.src = '/public/images/wizarding-clock-face.jpg';
        clockFace.alt = "Wizarding Clock Face";

        const scissorObj = new Image();
        scissorObj.src = '/public/images/half-scissor-outline.png';
        scissorObj.alt = "Clock Hand";
        const scissorEasing = cubicBezier(.33,-0.24,.56,1.07);

        const compareArrays = (a, b) => {
            return JSON.stringify(a) === JSON.stringify(b);
        };

        window.requestAnimationFrame(drawClock);

        async function drawClock() {
            // Add image to Canvas
            await refreshWizardData();
            ctx.resetTransform();
            ctx.clearRect(0, 0, 871, 846);
            ctx.drawImage(clockFace, 0, 0, canvas.width, canvas.height);
            ctx.translate(canvas.width / 2, canvas.height / 2);
            await drawNumbers(ctx, (canvas.height) / 2, clockPositions);
            await drawTime(ctx, (canvas.height) / 2, clockPositions, wizardWithPositionArray);
            window.requestAnimationFrame(drawClock);
        }


        async function refreshWizardData() {
            let updateOccurred = false;
            // Get the current data
            let response = await fetch('/clock/updateToClock', {
                method: 'GET'
            });
            let updatedData = await response.json();

            // Check against the current data
            if (!compareArrays(updatedData.clockPositions, clockPositions)) {
                clockPositions = updatedData.clockPositions;
                updateOccurred = true;
            }
            if (!compareArrays(updatedData.usersClockPositions, wizardWithPositionArray)) {
                wizardWithPositionArray = updatedData.usersClockPositions;
                updateOccurred = true;
            }

            if (updateOccurred || firstUpdate) {
                firstUpdate = false;

                // Update Wizard Info
                targetWizardState.length = 0;
                for (let num = 0; num < wizardWithPositionArray.length; num++) {
                    const wizardClockPosition = wizardWithPositionArray[num];
                    const wizardOffset = ((num - ((wizardWithPositionArray.length - 1) / 2)) / wizardWithPositionArray.length * 0.6);
                    let location = wizardOffset;
                    for (let loc of clockPositions) {
                        if (loc.name === wizardClockPosition.position.name) {
                            location = wizardOffset + loc.face_position;
                        }
                    }
                    location = (2 * Math.PI / clockPositions.length) * (location + .2);

                    targetWizardState.push({
                        wizard: wizardWithPositionArray[num].name,
                        pos: location,
                        length: (canvas.height / 2) * 0.7,
                        width: (canvas.height / 2) * 0.05,
                    });
                }
            }
        }

        // Much help from https://github.com/malcolmrigg/wizard-clock-card/tree/master
        async function drawNumbers(ctx, radius, positions) {
            let selectedFont = 'Xanh Mono';
            ctx.textBaseline = "middle";
            ctx.textAlign = "center";
            ctx.fillStyle = 'black';

            // Have to compensate for the clock not being a true circle
            const startingAdjustArray = [0.81, 0.82, 0.76, 0.76, 0.74, 0.74, 0.73, 0.73, 0.75, 0.73, 0.71, 0.71, .79];
            const ovalCompensateArray = [0, 5, 10, 10, 7, 3, 0, 3, 7, 6, 4, -2, -3];

            for (let num = 0; num < positions.length; num++) {
                // Unfun Required Math
                const positionTranslateArray = [-99, -75, -68, -72, -83,  -98,  -110, -122, -132, -140, -146, -148];
                const positionRotateArray =    [-55, -30,  -5,  20,  35,    40,   38,   38,   38,   28,   17,   10];
                const fontScaleArray =         [0.9, 0.8, 0.7, 0.6, 0.6,  0.55, 0.55,  0.5,  0.5, 0.45,  0.4, 0.35];
                const charWidthArray =              [3.8,   4, 3.9, 3.5,   2.8,  2.5,  2.5,  2.5,  2.8,  2.8,  2.8];

                ctx.resetTransform();
                ctx.translate(canvas.width/2, canvas.height/2);
                let ang = (2 * Math.PI / positions.length) * (num + startingAdjustArray[num]);
                ctx.rotate(ang);

                // Now draw, rotate, reset, and repeat
                let text = positions[num].name.toUpperCase();
                for (let j = 0; j < text.length; j++) {
                    ctx.font = "bold " + radius*0.15*fontScaleArray[j] + "px " + selectedFont;

                    // From Center to Edge
                    ctx.translate(0, (0 - (radius + ovalCompensateArray[num] + positionTranslateArray[j])));
                    // Rotate to letter position
                    ctx.rotate(positionRotateArray[j] * Math.PI /180);

                    ctx.fillText(text[j], 0, 0);

                    // Rotate back to straight
                    ctx.rotate(-positionRotateArray[j] * Math.PI /180);
                    // From Edge to Center
                    ctx.translate(0, -(0 - (radius + ovalCompensateArray[num] + positionTranslateArray[j])));

                    ctx.rotate((charWidthArray[j]) * Math.PI /180);
                }

            }
        }

        async function drawTime(ctx, radius){
            ctx.resetTransform();
            ctx.translate(canvas.width / 2, canvas.height / 2);

            if (currentWizardState.length === 0) {
                // Math for current wizard state creation
                for (let num = 0; num < wizardWithPositionArray.length; num++) {
                    const wizardOffset = ((num - ((wizardWithPositionArray.length - 1) / 2)) / wizardWithPositionArray.length * 0.6);
                    let location = (2 * Math.PI / clockPositions.length) * (wizardOffset + .2);

                    currentWizardState.push({
                        wizard: wizardWithPositionArray[num].name,
                        radToTravel: 0,
                        pos: location,
                        movingPos: location,
                        length: radius * 0.7,
                        width: radius * 0.05,
                    });

                }
            } else {
                // Math for incrementing wizard state
                for (let wizardCurrState of currentWizardState) {
                    for (let wizardTarget of targetWizardState) {
                        if (wizardCurrState.wizard === wizardTarget.wizard) {
                            if (wizardCurrState.pos !== wizardTarget.pos) {
                                // Initialize Pos Movement
                                if (wizardCurrState.radToTravel === 0) {
                                    // Fix any backwards movement
                                    let disToMove = wizardTarget.pos - wizardCurrState.pos;
                                    wizardCurrState.radToTravel = disToMove > 0 ? disToMove : disToMove + (2 * Math.PI);
                                    wizardCurrState.startTime = Date.now();
                                }

                                if (Date.now() - wizardCurrState.startTime <= 5000) {
                                    let easingRate = scissorEasing((Date.now() - wizardCurrState.startTime) / 5000);
                                    wizardCurrState.movingPos = wizardCurrState.pos + (wizardCurrState.radToTravel * easingRate);
                                } else {
                                    wizardCurrState.pos = wizardTarget.pos;
                                    wizardCurrState.movingPos = wizardTarget.pos;
                                }
                            } else {
                                wizardCurrState.radToTravel = 0;
                                wizardCurrState.startTime = 0;
                            }

                        }
                    }
                }
            }

            // draw currentState
            for (let wizardState of currentWizardState) {
                this.drawHand(ctx, wizardState.movingPos, wizardState.length, wizardState.width, wizardState.wizard);
            }
        }

        function drawHand(ctx, pos, length, width, wizard) {
            let fontScale = 0.3;
            let selectedFont = 'Aboreto';
            scissorObj.id = wizard + "-clock-hand";
            ctx.rotate(pos);
            ctx.drawImage(scissorObj, -20, -300, 75, 450);

            ctx.font = "bolder " + width * 3 * fontScale + "px " + selectedFont;
            ctx.fillStyle = "white";
            ctx.translate(0, -length / 2);
            ctx.rotate(Math.PI / 2)
            if (pos < Math.PI && pos >= 0) {
                ctx.rotate(Math.PI);
            }
            ctx.fillText(wizard.toUpperCase(), 0, 0);
            if (pos < Math.PI && pos >= 0) {
                ctx.rotate(-Math.PI);
            }
            ctx.rotate(-Math.PI / 2);
            ctx.translate(0, length / 2);

            ctx.rotate(-pos);
        }

        const editClockPositionModal = document.getElementById('editClockPositionModal');
        if (editClockPositionModal) {
            editClockPositionModal.addEventListener('show.bs.modal', async event => {
                document.getElementById('editClockPositionForm').reset();
                const button = event.relatedTarget;
                const clockPosition = JSON.parse(button.getAttribute('data-bs-position'));
                console.log(clockPosition.id)

                editClockPositionModal.setAttribute("data-bs-position-id", clockPosition.id);

                editClockPositionModal.querySelector('.pos-num').value = clockPosition.face_position;
                editClockPositionModal.querySelector('.pos-name').value = clockPosition.name;
            });
        }

        let editClockPositionForm = document.getElementById('editClockPositionForm');
        editClockPositionForm.onsubmit = async (e) => {
            e.preventDefault();

            let formData = new FormData(editClockPositionForm)
            let clockPositionID = editClockPositionModal.getAttribute("data-bs-position-id");
            formData.append("id", clockPositionID);

            let response = await fetch('/clock/editClockPosition', {
                method: 'POST',
                body: formData
            });
            let result = await response.json();
            if (result.success) {
                editClockPositionForm.reset();
                window.location.reload();
            } else {
                alert("Submission Error");
            }
        }



