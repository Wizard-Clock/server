extends layout

block content
    div(class="row justify-content-center")
        div(class="d-flex justify-content-center align-items-center")
            canvas(id="wizardingClockFace" class="img-fluid" width="871" height="846")

    script.
        const canvas = document.getElementById('wizardingClockFace');
        const ctx = canvas.getContext('2d');
        let clockPositions = JSON.parse('!{JSON.stringify(clockPositions)}');
        console.log(clockPositions);
        let usersClockPosition = JSON.parse('!{JSON.stringify(usersClockPosition)}');
        const currentState = [];
        const selectedFont = 'Aboreto';
        const fontScale = 0.3;

        // Add image to Canvas
        const img = new Image();
        img.crossOrigin = 'anonymous';
        img.src = '/public/images/wizarding-clock-face.jpg';
        img.alt = "Wizarding Clock Face";
        img.onload = function () {
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            ctx.translate(canvas.width/2, canvas.height/2);
            drawNumbers(ctx, (canvas.height-93)/2, clockPositions);
            drawTime(ctx, (canvas.height-93)/2, clockPositions, usersClockPosition);
        };


        // Much help from https://github.com/malcolmrigg/wizard-clock-card/tree/master
        async function drawNumbers(ctx, radius, positions) {
            let ang;
            let num;

            ctx.font = radius*0.15*fontScale + "px " + selectedFont;
            ctx.textBaseline = "middle";
            ctx.textAlign = "center";
            // ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--primary-text-color');
            ctx.fillStyle = 'black';

            for (num = 0; num < positions.length; num++) {
                ang = (num +1) * Math.PI / positions.length * 2;
                // rotate to center of drawing position
                ctx.rotate(ang);

                let startAngle = 0;
                let inwardFacing = true;
                let kerning = 0; // can adjust kerning using this - maybe automatically adjust it based on text length?
                let text = positions[num].name.split("").reverse().join("");

                // This lets bottom position names face right way up if wanted
                // if (ang > Math.PI / 2 && ang < ((Math.PI * 2) - (Math.PI / 2))) {
                //     startAngle = Math.PI;
                //     inwardFacing = false;
                //     text = positions[num];
                // }

                text = this.isRtlLanguage(text) ? text.split("").reverse().join("") : text;

                // calculate height of the font. Many ways to do this - you can replace with your own!
                const div = document.createElement("div");
                div.innerHTML = text;
                div.style.position = 'absolute';
                div.style.top = '-10000px';
                div.style.left = '-10000px';
                div.style.fontFamily = selectedFont;
                div.style.fontSize = radius * 0.15 * fontScale + "px";
                document.body.appendChild(div);
                const textHeight = div.offsetHeight;
                document.body.removeChild(div);

                // rotate 50% of total angle for center alignment
                for (let j = 0; j < text.length; j++) {
                    let charWid = ctx.measureText(text[j]).width;
                    startAngle += ((charWid + (j == text.length - 1 ? 0 : kerning)) / (radius - textHeight)) / 2;
                }

                // Phew... now rotate into final start position
                ctx.rotate(startAngle);

                // Now for the fun bit: draw, rotate, and repeat
                for (let j = 0; j < text.length; j++) {
                    let charWid = ctx.measureText(text[j]).width; // half letter
                    // rotate half letter
                    ctx.rotate((charWid / 2) / (radius - textHeight) * -1);
                    // draw the character at "top" or "bottom"
                    // depending on inward or outward facing
                    ctx.fillText(text[j], 0, (inwardFacing ? 1 : -1) * (0 - radius + textHeight));

                    ctx.rotate((charWid / 2 + kerning) / (radius - textHeight) * -1); // rotate half letter
                }
                // rotate back round from the end position to the central position of the text
                ctx.rotate(startAngle);

                // rotate to the next location
                ctx.rotate(-ang);
            }
        }

        function isRtlLanguage(text) {
            const rtlChar = /[\u0590-\u05FF\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]/;
            return rtlChar.test(text);
        }

        async function drawTime(ctx, radius, locations, wizardClockPositions){
            const targetState = [];
            for (let num = 0; num < wizardClockPositions.length; num++) {
                const wizardClockPosition = wizardClockPositions[num];
                const wizardOffset = ((num - ((wizardClockPositions.length - 1) / 2)) / wizardClockPositions.length * 0.6);
                let location = wizardOffset;
                for (let loc of locations) {
                    if (loc.name === wizardClockPosition.position.name) {
                        location = wizardOffset + loc.face_position;
                    }
                }
                location = location * Math.PI / locations.length * 2;

                // set targetstate
                targetState.push({
                    pos: location,
                    length: radius * 0.7,
                    width: radius * 0.05,
                    wizard: wizardClockPositions[num].name,
                });
            }

            // update currentstate from targetstate
            if (!currentState) {
                currentState.length = 0;
            }
            for (let num = 0; num < wizardClockPositions.length; num++) {
                if (currentState[num]) {
                    currentState[num].pos = currentState[num].pos + ((targetState[num].pos - currentState[num].pos) / 60);
                } else {
                    currentState.push({
                        pos: targetState[num].pos,
                        length: targetState[num].length,
                        width: targetState[num].width,
                        wizard: targetState[num].wizard
                    });
                }
            }
            // draw currentState
            for (let num = 0; num < wizardClockPositions.length; num++) {
                this.drawHand(ctx, currentState[num].pos, currentState[num].length, currentState[num].width, currentState[num].wizard);
            }
        }

        function drawHand(ctx, pos, length, width, wizard) {
            ctx.beginPath();
            ctx.lineWidth = width;
            ctx.fillStyle = "black";
            ctx.shadowColor = "#0008";
            ctx.shadowBlur = 10;
            ctx.shadowOffsetX = 5;
            ctx.shadowOffsetY = 5;
            ctx.moveTo(0, 0);
            ctx.rotate(pos);
            ctx.quadraticCurveTo(width, -length * 0.5, width, -length * 0.75);
            ctx.quadraticCurveTo(width * 0.2, -length * 0.8, 0, -length);
            ctx.quadraticCurveTo(-width * 0.2, -length * 0.8, -width, -length * 0.75);
            ctx.quadraticCurveTo(-width, -length * 0.5, 0, 0);

            ctx.fill();

            ctx.font = width * 3 * fontScale + "px " + selectedFont;
            ctx.fillStyle = "white";
            ctx.translate(0, -length / 2);
            ctx.rotate(Math.PI / 2)
            if (pos < Math.PI && pos >= 0)
                ctx.rotate(Math.PI);
            ctx.fillText(wizard, 0, 0);
            if (pos < Math.PI && pos >= 0)
                ctx.rotate(-Math.PI);
            ctx.rotate(-Math.PI / 2);
            ctx.translate(0, length / 2);

            ctx.rotate(-pos);
        }



